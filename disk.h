#ifndef _DISK_H_
#define _DISK_H_

#include "dev.h"
#include "spi.h"
#include "spi_cta.h"
#include "types.h"
//#include <string.h>   // For manufacturer string

#define SD_READ_BLK_LEN  512

#define SD_FLOATING_BUS  0xFF
#define SD_BUSY  0x00

#define REQ_START     0x00
#define REQ_TRANSMIT  0x40
#define REQ_CRC       0xF7   // Doesn't matter - see below
#define REQ_END       0x01

#define REQ_HEAD(command_index)  (uint8_t)(REQ_START | REQ_TRANSMIT | ((command_index) & 0x3F))
#define REQ_TAIL(crc7)           (uint8_t)(((uint8_t)(crc7) << 1) | REQ_END)

// GO_IDLE_STATE
// Resets SD Memory Card.  Used in this context to put the card into SPI mode.
// R1 response
#define REQ_CMD0_HEAD   REQ_HEAD(0)
#define REQ_CMD0_ARG    0x00000000
// CRC only necessary for CMD0 since when sending this the card is
// in SD as opposed to SPI mode which requires a checksum.  After
// this command is sent, the card is in SPI mode which does not require
// a valid checksum unless explicitly set via CMD59
#define REQ_CMD0_CRC7   0x4A  // 0x95 after left bit shift and end bit added
#define REQ_CMD0_TAIL   REQ_TAIL(REQ_CMD0_CRC7)

// SEND_IF_COND
// Sends SD Memory Card interface condition that includes host supply voltage
// information and asks the accessed card whether it can operate in the
// supplied voltage range.
// This command was introduced in the SD Group's Physical Layer Specification Version 2.00.
// If the illegal command bit is set in the R1 response, then the card is a Version 1.X
// SD Memory Card and therefore a Standard Capacity SD Memory Card - SDSC
// A valid CRC7 is always required for this command regardless of the CMD59 setting.
// R7 response
#define CMD8_CHECK_PATTERN          0xAA    // Has to be echoed in response
#define CMD8_VHS_UNDEFINED          0x00
#define CMD8_VHS_2_7_TO_3_6         0x01
#define CMD8_VHS_RESVD_LOW_VOLTAGE  0x02
#define CMD8_VHS_RESERVED           0x0C

#define REQ_CMD8_HEAD   REQ_HEAD(8)
#define REQ_CMD8_ARG    (uint32_t)((CMD8_VHS_2_7_TO_3_6 << 8) | CMD8_CHECK_PATTERN)
#define REQ_CMD8_CRC7   0x43  // 0x87 after left bit shift and end bit added
                              // and assuming 0xAA is the check pattern
#define REQ_CMD8_TAIL   REQ_TAIL(REQ_CMD8_CRC7)

// APP_CMD
// Must be sent before application specific commands, i.e. ACMDs.  Really used
// in this context before sending an ACMD41 which is one of many that are already
// "reserved for the SD Memory Card proprietary applications and shall not be used
// by any SD Memory Card manufacturer".
// R1 response
#define REQ_CMD55_HEAD  REQ_HEAD(55)
#define REQ_CMD55_ARG   0x00000000
#define REQ_CMD55_TAIL  REQ_TAIL(REQ_CRC)

// SD_SEND_OP_COND
// Sends host capacity support information and activates the card's
// initialization process.  Set HCS bit to say we support high
// capacity cards if CMD8 was recognized.  This command must be repeatedly
// sent until the idle state bit is cleared in the response.
// R1 response
#define REQ_ACMD41_HEAD      REQ_HEAD(41)
#define REQ_ACMD41_ARG(hcs)  (uint32_t)((hcs) ? (1 << 30) : 0)  // HCS == Host Capacity Support
#define REQ_ACMD41_TAIL      REQ_TAIL(REQ_CRC)

// READ_OCR
// Reads the OCR register of the card.  If the CCS (Card Capacity Status) bit
// is set in the response, then this is a high capacity card - SDHC or SDXC -
// otherwise it is standard capacity - SDSC.  The difference matters in block
// reads, writes and locks.  SDSC argument is a byte offset and SDHC and
// SDXC argument is a 512 byte block offset.
// R3 response
#define REQ_CMD58_HEAD  REQ_HEAD(58)
#define REQ_CMD58_ARG   0x00000000
#define REQ_CMD58_TAIL  REQ_TAIL(REQ_CRC)

// SEND_CSD
// Asks card to send its card-specific data (CSD)
#define REQ_CMD9_HEAD  REQ_HEAD(9)
#define REQ_CMD9_ARG   0x00000000
#define REQ_CMD9_TAIL  REQ_TAIL(REQ_CRC)

// SEND_CID
// Asks card to send its card-specific data (CSD)
#define REQ_CMD10_HEAD  REQ_HEAD(10)
#define REQ_CMD10_ARG   0x00000000
#define REQ_CMD10_TAIL  REQ_TAIL(REQ_CRC)

// READ_SINGLE_BLOCK
// For SDSC, reads a block of the size selected by the SET_BLOCKLEN command
// (CMD16) which if not explicitly set, supposedly defaults to 512 bytes.
// For SDHC and SDXC, reads a block of size 512 bytes regardless of SET_BLOCKLEN
// command.  Argument for SDSC is a byte offset and for SDHC and SDXC, a block offset.
// R1 response followed by a start block token then block size bytes of data and
// suffixed with a 16-bit CRC generated by the standard CCITT
// polynomial x^16 + x^12 + x^5 + 1.
// Also from the specification, it sounds like instead of a start block token,
// a data error token may be sent if the card can't provide the required data.
#define REQ_CMD17_HEAD            REQ_HEAD(17)
#define REQ_CMD17_ARG(addr, hc)   ((hc) ? (addr) : ((addr) << 9))
#define REQ_CMD17_TAIL            REQ_TAIL(REQ_CRC)

#define RESP_START_BLOCK_TOKEN   0xFE

#define RESP_DATA_ERROR_TOKEN_MASK  0x0F
#define RESP_DATA_ERROR_TOKEN_GENERAL_OR_UNKNOWN   0x01
#define RESP_DATA_ERROR_TOKEN_CARD_CONTROLLER      0x02
#define RESP_DATA_ERROR_TOKEN_CARD_ECC_FAILED      0x04
#define RESP_DATA_ERROR_TOKEN_OUT_OF_RANGE_OR_CSD  0x08

// WRITE_SINGLE_BLOCK
// For SDSC, write a block of the size selected by the SET_BLOCKLEN command
// (CMD16) which if not explicitly set, supposedly defaults to 512 bytes.
// For SDHC and SDXC, write a block of size 512 bytes regardless of SET_BLOCKLEN
// command.  Argument for SDSC is a byte offset and for SDHC and SDXC, a block offset.
// R1 response followed by writing a start block token then block size bytes of data
// and suffixed with a 16-bit CRC generated by the standard CCITT
// polynomial x^16 + x^12 + x^5 + 1.  Will get a data response token followed by
// some length of time where the line is held low or busy.  If the data response
// token indicates an error, use CMD13 (SEND_STATUS) to get specific error.
#define REQ_CMD24_HEAD            REQ_HEAD(24)
#define REQ_CMD24_ARG(addr, hc)   ((hc) ? (addr) : ((addr) << 9))
#define REQ_CMD24_TAIL            REQ_TAIL(REQ_CRC)

// Data Response Token
//
//   7   6   5   4   3   2   1   0
// ---------------------------------
// | x | x | x | 0 |  Status   | 1 |
// ---------------------------------
//
// Status bits
// ----------------------------------------
// 010 - Data accepted
// 101 - Data rejected due to a CRC error
// 110 - Data rejected due to a Write error
#define RESP_DATA_RESPONSE_TOKEN_MASK  0x1F
#define RESP_DATA_RESPONSE_TOKEN_VALID(resp)   (((resp) & 0x11) == 0x01)
#define RESP_DATA_RESPONSE_TOKEN_STATUS(resp)  (((resp) & RESP_DATA_RESPONSE_TOKEN_MASK) >> 1)
#define RESP_DATA_RESPONSE_TOKEN_ACCEPTED(resp)    (RESP_DATA_RESPONSE_TOKEN_STATUS(resp) == 0x02)
#define RESP_DATA_RESPONSE_TOKEN_CRC_ERROR(resp)   (RESP_DATA_RESPONSE_TOKEN_STATUS(resp) == 0x05)
#define RESP_DATA_RESPONSE_TOKEN_WRITE_ERROR(resp) (RESP_DATA_RESPONSE_TOKEN_STATUS(resp) == 0x06)

// SEND_STATUS
// Asks the card to send its status register.  Will get an R2 response.
#define REQ_CMD13_HEAD  REQ_HEAD(13)
#define REQ_CMD13_ARG   0x00000000  // Stuff bits
#define REQ_CMD13_TAIL  REQ_TAIL(REQ_CRC)

#define RESP_R1_READY            0x00
#define RESP_R1_IDLE_STATE       0x01
#define RESP_R1_ERASE_RESET      0x02
#define RESP_R1_ERR_ILLEGAL_CMD  0x04
#define RESP_R1_ERR_CMD_CRC      0x08
#define RESP_R1_ERR_ERASE_SEQ    0x10
#define RESP_R1_ERR_ADDRESS      0x20
#define RESP_R1_ERR_PARAMETER    0x40
#define RESP_R1_TRANSMIT         0x80   // Should NEVER be set
#define RESP_R1_ERROR (         \
    RESP_R1_ERR_ILLEGAL_CMD |   \
    RESP_R1_ERR_CMD_CRC     |   \
    RESP_R1_ERR_ERASE_SEQ   |   \
    RESP_R1_ERR_ADDRESS     |   \
    RESP_R1_ERR_PARAMETER   )

#define RESP_R2_ERR_CARD_LOCKED                    0x01
#define RESP_R2_ERR_WP_ERASE_OR_LOCK_UNLOCK_FAILED 0x02
#define RESP_R2_ERR_GENERAL_OR_UNKNOWN             0x04
#define RESP_R2_ERR_CARD_CONTROLLER                0x08
#define RESP_R2_ERR_CARD_ECC_FAILED                0x10
#define RESP_R2_ERR_WRITE_PROTECT_VIOLATION        0x20
#define RESP_R2_ERR_INVALID_ERASE_PARAM            0x40
#define RESP_R2_ERR_OUT_OF_RANGE_OR_CSD            0x80
#define RESP_R2_ERROR (                             \
    RESP_R2_ERR_CARD_LOCKED                     |   \
    RESP_R2_ERR_WP_ERASE_OR_LOCK_UNLOCK_FAILED  |   \
    RESP_R2_ERR_GENERAL_UNKNOWN                 |   \
    RESP_R2_ERR_CARD_CONTROLLER                 |   \
    RESP_R2_ERR_CARD_ECC_FAILED                 |   \
    RESP_R2_ERR_WRITE_PROTECT_VIOLATION         |   \
    RESP_R2_ERR_INVALID_ERASE_PARAM             |   \
    RESP_R2_ERR_OUT_OF_RANGE_OR_CSD             )

// In R3 response to CMD58
#define OCR_REG_RESERVED_1            0x00007FFF
#define OCR_REG_VDD_2_7_to_2_8        0x00008000
#define OCR_REG_VDD_2_8_to_2_9        0x00010000
#define OCR_REG_VDD_2_9_to_3_0        0x00020000
#define OCR_REG_VDD_3_0_to_3_1        0x00040000
#define OCR_REG_VDD_3_1_to_3_2        0x00080000
#define OCR_REG_VDD_3_2_to_3_3        0x00100000
#define OCR_REG_VDD_3_3_to_3_4        0x00200000
#define OCR_REG_VDD_3_4_to_3_5        0x00400000
#define OCR_REG_VDD_3_5_to_3_6        0x00800000
#define OCR_REG_VDD_1_8_ACCEPTED      0x01000000
#define OCR_REG_RESERVED_2            0x1E000000
#define OCR_REG_UHS_II_CARD_STATUS    0x20000000
#define OCR_REG_CARD_CAPACITY_STATUS  0x40000000
#define OCR_REG_CARD_POWER_UP_STATUS  0x80000000
#define OCR_REG_RESERVED  (OCR_REG_RESERVED_1 | OCR_REG_RESERVED_2)
#define OCR_REG_VDD (         \
    OCR_REG_VDD_2_7_to_2_8  |  \
    OCR_REG_VDD_2_8_to_2_9  |  \
    OCR_REG_VDD_2_9_to_3_0  |  \
    OCR_REG_VDD_3_0_to_3_1  |  \
    OCR_REG_VDD_3_1_to_3_2  |  \
    OCR_REG_VDD_3_2_to_3_3  |  \
    OCR_REG_VDD_3_3_to_3_4  |  \
    OCR_REG_VDD_3_4_to_3_5  |  \
    OCR_REG_VDD_3_5_to_3_6  )
#define SD_HIGH_CAPACITY(ocr)  ((ocr) & OCR_REG_CARD_CAPACITY_STATUS)

// In R7 response to CMD8
#define RESP_R7_CHECK_PATTERN    0x000000FF
#define RESP_R7_VHS              0x00000F00
#define RESP_R7_VHS_UNDEFINED    0x00000000
#define RESP_R7_VHS_2_7_TO_3_6   0x00000100
#define RESP_R7_VHS_RESVD_LOW_V  0x00000200
#define RESP_R7_VHS_RESERVED     0x00000C00

template < pin_t CS, template < pin_t, pin_t, pin_t > class SPI, pin_t MOSI, pin_t MISO, pin_t SCK >
class DevSD : public DevDisk < SD_READ_BLK_LEN, CS, SPI, MOSI, MISO, SCK >
{
    using Tdisk = DevDisk < SD_READ_BLK_LEN, CS, SPI, MOSI, MISO, SCK >;

    public:
        static DevSD & acquire(void) { static DevSD sd; return sd; }
        virtual bool valid(void) { return Tdisk::valid() && _valid; }

        virtual bool read(uint32_t addr, uint8_t (&buf)[SD_READ_BLK_LEN]);
        virtual bool write(uint32_t addr, uint8_t (&buf)[SD_READ_BLK_LEN]);

        virtual uint32_t capacity(void) { return _csd.cardCapacity(); }
        virtual uint32_t blocks(void) { return _csd.numBlocks(); }

        virtual bool busy(void) { return _busy; }

        DevSD(DevSD const &) = delete;
        DevSD & operator=(DevSD const &) = delete;

    private:
        DevSD(void);

        uint8_t sendCmd(uint8_t head, uint32_t arg, uint8_t tail);
        void endCmd(void);

        void clock74(void);
        bool spiMode(void);
        bool checkVersion(void);
        bool cmd58(uint32_t & ocr);
        bool checkVoltage(void);
        bool ready(void);
        bool checkCapacity(void);
        bool getCSD(void);
        bool getCID(void);

        bool _hcs = false;
        bool _hc = false;

        bool _busy = false;
        bool _valid = true;

////////////////////////////////////////////////////////////////////////////////////////////////////
//
// CSD Version 1.0
//
// Name                              Field              Width          Value   Cell Type   CSD-slice
// -------------------------------------------------------------------------------------------------
// CSD Structure                     CSD_STRUCTURE          2            00b       R       [127:126]
// reserved                          -                      6       00 0000b       R       [125:120]
// data read access-time-1           TAAC                   8            xxh       R       [119:112]
// data read access-time-2           NSAC                   8            xxh       R       [111:104]
// max. data transfer rate           TRAN_SPEED             8     32h or 5Ah       R       [103:96]
// card command classes              CCC                   12  01x110110101b       R       [95:84]
// max. read data block length       READ_BL_LEN            4             xh       R       [83:80]
// partial blocks for read allowed   READ_BL_PARTIAL        1             1b       R       [79:79]
// write block misalignment          WRITE_BLK_MISALIGN     1             xb       R       [78:78]
// read block misalignment           READ_BLK_MISALIGN      1             xb       R       [77:77]
// DSR implemented                   DSR_IMP                1             xb       R       [76:76]
// reserved                          -                      2            00b       R       [74:75]
// device size                       C_SIZE                12           xxxh       R       [73:62]
// max. read current @ VDD min       VDD_R_CURR_MIN         3           xxxb       R       [61:59]
// max. read current @ VDD max       VDD_R_CURR_MAX         3           xxxb       R       [58:56]
// max. write current @ VDD min      VDD_W_CURR_MIN         3           xxxb       R       [55:53]
// max. write current @ VDD max      VDD_W_CURR_MAX         3           xxxb       R       [52:50]
// device size multiplier            C_SIZE_MULT            3           xxxb       R       [49:47]
// erase single block enable         ERASE_BLK_EN           1             xb       R       [46:46]
// erase sector size                 SECTOR_SIZE            7       xxxxxxxb       R       [45:39]
// write protect group size          WP_GRP_SIZE            7       xxxxxxxb       R       [38:32]
// write protect group enable        WP_GRP_ENABLE          1             xb       R       [31:31]
// reserved                          -                      2            00b       R       [30:29]
// write speed factor                R2W_FACTOR             3           xxxb       R       [28:26]
// max. write data block length      WRITE_BL_LEN           4          xxxxb       R       [25:22]
// partial blocks for write allowed  WRITE_BL_PARTIAL       1             xb       R       [21:21]
// reserved                          -                      5         00000b       R       [20:16]
// File format group                 FILE_FORMAT_GRP        1             xb      R/W(1)   [15:15]
// copy flag                         COPY                   1             xb      R/W(1)   [14:14]
// permanent write protection        PERM_WRITE_PROTECT     1             xb      R/W(1)   [13:13]
// temporary write protection        TMP_WRITE_PROTECT      1             xb      R/W      [12:12]
// File format                       FILE_FORMAT            2            xxb      R/W(1)   [11:10]
// reserved                          -                      2            00b      R/W      [9:8]
// CRC                               CRC                    7       xxxxxxxb      R/W      [7:1]
// not used, always '1'              -                      1             1b       -       [0:0]
//
// R = readable, W(1) = writable once, W = multiple writable
//
////////////////////////////////////////////////////////////////////////////////////////////////////
//
// CSD Version 2.0
//
// Name                              Field              Width          Value   Cell Type   CSD-slice
// -------------------------------------------------------------------------------------------------
// CSD Structure                     CSD_STRUCTURE          2            01b       R       [127:126]
// reserved                          -                      6       00 0000b       R       [125:120]
// data read access-time-1           TAAC                   8            0Eh       R       [119:112]
// data read access-time-2           NSAC                   8            00h       R       [111:104]
// max. data transfer rate           TRAN_SPEED             8  32h,5Ah,0Bh,2Bh     R       [103:96]
// card command classes              CCC                   12  x1x110110101b       R       [95:84]
// max. read data block length       READ_BL_LEN            4             9h       R       [83:80]
// partial blocks for read allowed   READ_BL_PARTIAL        1             0b       R       [79:79]
// write block misalignment          WRITE_BLK_MISALIGN     1             0b       R       [78:78]
// read block misalignment           READ_BLK_MISALIGN      1             0b       R       [77:77]
// DSR implemented                   DSR_IMP                1             xb       R       [76:76]
// reserved                          -                      6       00 0000b       R       [75:70]
// device size                       C_SIZE                22        xxxxxxh       R       [69:48]
// reserved                          -                      1             0b       R       [47:47]
// erase single block enable         ERASE_BLK_EN           1             1b       R       [46:46]
// erase sector size                 SECTOR_SIZE            7            7Fh       R       [45:39]
// write protect group size          WP_GRP_SIZE            7       0000000b       R       [38:32]
// write protect group enable        WP_GRP_ENABLE          1             0b       R       [31:31]
// reserved                          -                      2            00b       R       [30:29]
// write speed factor                R2W_FACTOR             3           010b       R       [28:26]
// max. write data block length      WRITE_BL_LEN           4             9h       R       [25:22]
// partial blocks for write allowed  WRITE_BL_PARTIAL       1             0b       R       [21:21]
// reserved                          -                      5         00000b       R       [20:16]
// File format group                 FILE_FORMAT_GRP        1             0b       R       [15:15]
// copy flag                         COPY                   1             xb      R/W(1)   [14:14]
// permanent write protection        PERM_WRITE_PROTECT     1             xb      R/W(1)   [13:13]
// temporary write protection        TMP_WRITE_PROTECT      1             xb      R/W      [12:12]
// File format                       FILE_FORMAT            2            00b       R       [11:10]
// reserved                          -                      2            00b       R       [9:8]
// CRC                               CRC                    7       xxxxxxxb      R/W      [7:1]
// not used, always '1'              -                      1             1b       -       [0:0]
//
// R = readable, W(1) = writable once, W = multiple writable
//
////////////////////////////////////////////////////////////////////////////////////////////////////
        struct CSD
        {
            // XXX Should never get a Version 1.0 CSD since high/extended capacity is a requirement
            enum version_e : uint8_t
            {
                VERSION_1_0,  // Standard Capacity Card
                VERSION_2_0,  // High and Extended Capacity Cards
                RESERVED_2,
                RESERVED_3,
            };

            // In Kilobytes
            uint32_t cardCapacity(void) const
            {
                uint32_t capacity = 0;

                if (csd_structure() == VERSION_1_0)
                {
                    uint32_t block_len = 1 << read_bl_len();   // READ_BL_LEN < 12 ???
                    uint32_t mult = 1 << (c_size_mult() + 2);  // C_SIZE_MULT <  8 ???
                    uint32_t blocknr = (c_size() + 1) * mult;
                    capacity = (blocknr * block_len) / 1024;
                }
                else if (csd_structure() == VERSION_2_0)
                {
                    capacity = (c_size() + 1) * 512;
                }

                return capacity;
            }

            uint32_t numBlocks(void) const
            {
                uint32_t num_blocks = 0;

                if (csd_structure() == VERSION_1_0)
                {
                    uint32_t mult = 1 << (c_size_mult() + 2);
                    num_blocks = (c_size() + 1) * mult;
                }
                else if (csd_structure() == VERSION_2_0)
                {
                    // Will wrap to 0 if card is max capacity of 2 TB
                    // If card capacity is not zero then a return value of zero
                    // indicates 2^32, otherwise 0.
                    num_blocks = (c_size() + 1) * 1024;
                }

                return num_blocks;
            }

            uint32_t readBlockLen(void) const { return 1 << read_bl_len(); }
            uint32_t writeBlockLen(void) const { return 1 << write_bl_len(); }

            // Data is transmitted MSb first so byte ordering will be the reverse of the above
            // but bit ordering in byte will be the same.

            version_e csd_structure(void) const { return (version_e)((_buffer[0] & 0xC0) >> 6); }
            uint8_t taac(void) const { return _buffer[1]; }
            uint8_t nsac(void) const { return _buffer[2]; }
            uint8_t trans_speed(void) const { return _buffer[3]; }
            uint16_t ccc(void) const { return ((uint16_t)_buffer[4] << 4) | (_buffer[5] >> 4); }
            uint8_t read_bl_len(void) const { return _buffer[5] & 0x0F; }
            bool read_bl_partial(void) const { return _buffer[6] & 0x80; }
            bool write_blk_misalign(void) const { return _buffer[6] & 0x40; }
            bool read_blk_misalign(void) const { return _buffer[6] & 0x20; }
            bool dsr_imp(void) const { return _buffer[6] & 0x10; }

            uint32_t c_size(void) const
            {
                uint32_t csize = 0;

                if (csd_structure() == VERSION_1_0)
                    csize = ((uint32_t)(_buffer[6] & 0x03) << 10)
                        | ((uint32_t)_buffer[7] << 2) | ((_buffer[8] & 0xC0) >> 6);
                else if (csd_structure() == VERSION_2_0)
                    csize = ((uint32_t)(_buffer[7] & 0x3F) << 16) | ((uint32_t)_buffer[8] << 8) | _buffer[9];

                return csize;
            }

            // Only for v1
            uint8_t vdd_r_curr_min(void) const { return (_buffer[8] & 0x38) >> 3; }
            uint8_t vdd_r_curr_max(void) const { return _buffer[8] & 0x07; }
            uint8_t vdd_w_curr_min(void) const { return (_buffer[9] & 0xE0) >> 5; }
            uint8_t vdd_w_curr_max(void) const { return (_buffer[9] & 0x1C) >> 2; }
            uint8_t c_size_mult(void) const { return ((_buffer[9] & 0x03) << 1) | ((_buffer[10] & 0x80) >> 7); }

            bool erase_blk_en(void) const { return _buffer[10] & 0x40; }
            uint8_t sector_size(void) const { return ((_buffer[10] & 0x3F) << 1) | ((_buffer[11] & 0x80) >> 7); }
            uint8_t wp_grp_size(void) const { return _buffer[11] & 0x7F; }
            bool wp_grp_enable(void) const { return _buffer[12] & 0x80; }
            uint8_t r2w_factor(void) const { return (_buffer[12] & 0x1C) >> 2; }
            uint8_t write_bl_len(void) const { return ((_buffer[12] & 0x03) << 2) | ((_buffer[13] & 0xC0) >> 6); }
            bool write_bl_partial(void) const { return _buffer[13] & 0x20; }
            bool file_format_grp(void) const { return _buffer[14] & 0x80; }
            bool copy(void) const { return _buffer[14] & 0x40; }
            bool perm_write_protect(void) const { return _buffer[14] & 0x20; }
            bool tmp_write_protect(void) const { return _buffer[14] & 0x10; }
            uint8_t file_format(void) const { return (_buffer[14] & 0x0C) >> 2; }
            uint8_t crc(void) const { return (_buffer[15] & 0xFE) >> 1; }
            bool always_one(void) const { return _buffer[15] & 0x01; }

            uint8_t _buffer[16];
        };

        CSD _csd;

////////////////////////////////////////////////////////////////////////////////
//
// CID Register
//
// Name                      Field    Width     CID-slice
// ------------------------------------------------------
// Manufacturer ID           MID          8     [127:120]
// OEM/Application ID        OID         16     [119:104]
// Product Name              PNM         40     [103:64]
// Product Revision          PRV          8     [63:56]
// Product Serial Number     PSN         32     [55:24]
// reserved                  ---          4     [23:20]
// Manufacturing Date        MDT         12     [19:8]
// CRC7 checksum             CRC          7     [7:1]
// not used, always 1        ---          1     [0:0]
//
////////////////////////////////////////////////////////////////////////////////
        struct CID
        {
            // Taken from linux kernel drivers/mmc/core/card.h, tesing and
            // online sources.  Commented entries are from linux kernel code.
            enum manufacturer_id_e : uint8_t
            {
                PANASONIC  = 0x01,
                TOSHIBA    = 0x02,
                //SANDISK    = 0x02,
                SANDISK    = 0x03,
                ATP        = 0x09,
                //TOSHIBA    = 0x11,
                MICRON     = 0x13,
                //SAMSUNG    = 0x15,
                SAMSUNG    = 0x1B,  // Obtained from testing
                ADATA      = 0x1D,
                PATRIOT    = 0x27,
                //APACER     = 0x27,
                APACER     = 0x28,
                //KINGSTON   = 0x70,  // Most Kingston seem to be Toshiba
                HYNIX      = 0x90,
            };

            enum oem_id_e : uint16_t
            {
                OEM_PANASONIC  = 0x5041,  // "PA"
                OEM_TOSHIBA    = 0x544D,  // "TM"
                OEM_SANDISK    = 0x5344,  // "SD"
                OEM_ATP        = 0x4150,  // "AP"
                OEM_SAMSUNG    = 0x534D,  // "SM"
                OEM_ADATA      = 0x4144,  // "AD"
                OEM_PATRIOT    = 0x5048,  // "PH"
                OEM_APACER     = 0x4245,  // "BE"
            };

            // Data is transmitted MSb first so byte ordering will be the reverse of the above
            // but bit ordering in byte will be the same.

            uint8_t mid(void) const { return _buffer[0]; }
            uint16_t oid(void) const { return ((uint16_t)_buffer[1] << 8) | (uint16_t)_buffer[2]; }
            uint8_t const * pnm(void) const { return &_buffer[3]; }
            uint8_t prv(void) const { return _buffer[8]; }
            uint32_t psn(void) const
            {
                return ((uint32_t)_buffer[9] << 24) | ((uint32_t)_buffer[10] << 16)
                    | ((uint32_t)_buffer[11] <<  8) | ((uint32_t)_buffer[12] <<  0);
            }

            uint16_t mdt(void) const { return (((uint16_t)_buffer[13] & 0x0F) << 8) | (uint16_t)_buffer[14]; }
            uint8_t crc(void) const { return (_buffer[15] & 0xFE) >> 1; }
            bool always_one(void) const { return _buffer[15] & 0x01; }

            uint8_t _buffer[16];
        };

        CID _cid;

#if 0
        uint8_t _manufacturer[16];
        uint8_t _product_name[6];

        void setManufacturer(void)
        {
            switch (_cid.mid())
            {
                case CID::PANASONIC:
                    strcpy(_manufacturer, "PANASONIC");
                    break;
                case CID::TOSHIBA:
                    strcpy(_manufacturer, "TOSHIBA");
                    break;
                case CID::SANDISK:
                    strcpy(_manufacturer, "SANDISK");
                    break;
                case CID::ATP:
                    strcpy(_manufacturer, "ATP");
                    break;
                case CID::MICRON:
                    strcpy(_manufacturer, "MICRON");
                    break;
                case CID::SAMSUNG:
                    strcpy(_manufacturer, "SAMSUNG");
                    break;
                case CID::ADATA:
                    strcpy(_manufacturer, "ADATA");
                    break;
                case CID::PATRIOT:
                    strcpy(_manufacturer, "PATRIOT");
                    break;
                case CID::APACER:
                    strcpy(_manufacturer, "APACER");
                    break;
                case CID::HYNIX:
                    strcpy(_manufacturer, "HYNIX");
                    break;
                default:
                    strcpy(_manufacturer, "UNKNOWN");
                    break;
            }
        }

        void setProductName(void) { memcpy(_product_name, _cid.pnm(), 5); _product_name[5] = 0; }
#endif
};

template < pin_t CS, template < pin_t, pin_t, pin_t > class SPI, pin_t MOSI, pin_t MISO, pin_t SCK >
DevSD < CS, SPI, MOSI, MISO, SCK >::DevSD(void)
{
    if (!valid())
        return;

    // Start with a 375kHz clock - largest clock less than 400kHz
    // Not really clear from spec what other values should be
    this->_cta = spi_cta(400000, 0, 0, 0);

    clock74();

    if (!spiMode() || !checkVersion() || !checkVoltage() || !ready() || !checkCapacity())
    {
        _valid = false;
        return;
    }

    // Can set clock higher now.  May actually be able to do after ready.
    this->_cta = spi_cta(25000000, 0, 0, 0);

    (void)getCSD();
    if ((_csd.readBlockLen() != _csd.writeBlockLen())
            || (_csd.readBlockLen() != SD_READ_BLK_LEN))
    {
        _valid = false;
        return;
    }

    (void)getCID();
}

template < pin_t CS, template < pin_t, pin_t, pin_t > class SPI, pin_t MOSI, pin_t MISO, pin_t SCK >
uint8_t DevSD < CS, SPI, MOSI, MISO, SCK >::sendCmd(uint8_t head, uint32_t arg, uint8_t tail)
{
    // All commands will get an R1 response and according to the
    // specification it can take up to NCR (command response timeout)
    // times to get one.  A SanDisk spec sheet indicates this can be
    // a maximum of 8 units, each unit being 8 clock cycles, so
    // try 8 times to get a response.  It seems that the line
    // will be held high or floating until a valid repsonse is seen.
    // Also, a response never has the first bit set so that may be a
    // valid check as well.

    // In bytes, i.e number of 8-bit transfers
    static uint8_t const r1_resp_tries = 8;

    _busy = true;

    this->_spi.begin(this->_pin, this->_cta);

    // Send command
    this->_spi.tx8(head);
    this->_spi.tx32(arg);
    this->_spi.tx8(tail);
    this->_spi.flush();

    // Wait for response
    uint8_t r1;
    for (uint8_t i = 0; i < r1_resp_tries; i++)
    {
        if ((r1 = this->_spi.txrx8(0xFF)) != SD_FLOATING_BUS)
            break;
    }

    return r1;
}

template < pin_t CS, template < pin_t, pin_t, pin_t > class SPI, pin_t MOSI, pin_t MISO, pin_t SCK >
void DevSD < CS, SPI, MOSI, MISO, SCK >::endCmd(void)
{
    this->_spi.end(this->_pin);
    (void)this->_spi.txrx8(0xFF);  // I think spec says to do this or at least wait 8 clocks.
    _busy = false;
}

template < pin_t CS, template < pin_t, pin_t, pin_t > class SPI, pin_t MOSI, pin_t MISO, pin_t SCK >
void DevSD < CS, SPI, MOSI, MISO, SCK >::clock74(void)
{
    // Number of clocks to send *without* chip select asserted before sending
    // first command.  Specification says a minimum of 74 clocks.  Send 80.
    // 6.4.1.1 Power Up Time of Card (third bullet)
    // * ... In case of SPI mode, CS shall be held to high during 74 clock cycles.
    static uint8_t const sd_init_clocks = 80;

    _busy = true;

    this->_spi.begin(this->_cta);

    for (uint8_t i = 0; i < (sd_init_clocks >> 4); i++)
        this->_spi.tx16(0xFFFF);

    this->_spi.end();

    _busy = false;
}

template < pin_t CS, template < pin_t, pin_t, pin_t > class SPI, pin_t MOSI, pin_t MISO, pin_t SCK >
bool DevSD < CS, SPI, MOSI, MISO, SCK >::spiMode(void)
{
    static uint32_t const cmd0_timeout = 250;
    uint8_t resp;
    uint32_t ts = msecs();

    while (true)
    {
        resp = sendCmd(REQ_CMD0_HEAD, REQ_CMD0_ARG, REQ_CMD0_TAIL);

        if ((resp == RESP_R1_IDLE_STATE) || ((msecs() - ts) > cmd0_timeout))
            break;

        endCmd();
    }

    endCmd();

    return (resp == RESP_R1_IDLE_STATE);
}

template < pin_t CS, template < pin_t, pin_t, pin_t > class SPI, pin_t MOSI, pin_t MISO, pin_t SCK >
bool DevSD < CS, SPI, MOSI, MISO, SCK >::checkVersion(void)
{
    uint8_t resp = sendCmd(REQ_CMD8_HEAD, REQ_CMD8_ARG, REQ_CMD8_TAIL);

    if ((resp & RESP_R1_ERROR) == RESP_R1_ERR_ILLEGAL_CMD)
    {
        _hcs = false;
        _hc = false;
    }
    else if (resp & RESP_R1_ERROR)
    {
        endCmd();
        return false;
    }
    else
    {
        uint32_t r7 = this->_spi.txrx32(0xFFFFFFFF);
        if ((r7 & REQ_CMD8_ARG) != REQ_CMD8_ARG)
        {
            endCmd();
            return false;
        }

        _hcs = true;
    }

    endCmd();

    return true;
}

template < pin_t CS, template < pin_t, pin_t, pin_t > class SPI, pin_t MOSI, pin_t MISO, pin_t SCK >
bool DevSD < CS, SPI, MOSI, MISO, SCK >::cmd58(uint32_t & ocr)
{
    uint8_t resp = sendCmd(REQ_CMD58_HEAD, REQ_CMD58_ARG, REQ_CMD58_TAIL);

    if (resp & RESP_R1_ERROR)
    {
        endCmd();
        return false;
    }

    ocr = this->_spi.txrx32(0xFFFFFFFF);

    endCmd();

    return true;
}

template < pin_t CS, template < pin_t, pin_t, pin_t > class SPI, pin_t MOSI, pin_t MISO, pin_t SCK >
bool DevSD < CS, SPI, MOSI, MISO, SCK >::checkVoltage(void)
{
    uint32_t ocr;

    if (!cmd58(ocr))
        return false;

    // XXX Should probably zero in on a value or smaller set of values
    if (!(ocr & OCR_REG_VDD))
        return false;

    return true;
}

template < pin_t CS, template < pin_t, pin_t, pin_t > class SPI, pin_t MOSI, pin_t MISO, pin_t SCK >
bool DevSD < CS, SPI, MOSI, MISO, SCK >::ready(void)
{
    static uint32_t const acmd41_timeout = 1500;
    uint8_t resp;
    uint32_t ts = msecs();

    while (true)
    {
        // CMD55
        resp = sendCmd(REQ_CMD55_HEAD, REQ_CMD55_ARG, REQ_CMD55_TAIL);
        if (resp & RESP_R1_ERROR)
            break;

        endCmd();

        // ACMD41
        resp = sendCmd(REQ_ACMD41_HEAD, REQ_ACMD41_ARG(_hcs), REQ_ACMD41_TAIL);
        if ((resp != RESP_R1_IDLE_STATE) || ((msecs() - ts) > acmd41_timeout))
            break;

        endCmd();
    }

    endCmd();

    return (resp == RESP_R1_READY);
}

template < pin_t CS, template < pin_t, pin_t, pin_t > class SPI, pin_t MOSI, pin_t MISO, pin_t SCK >
bool DevSD < CS, SPI, MOSI, MISO, SCK >::checkCapacity(void)
{
    uint32_t ocr;

    if (!_hcs)
        return true;

    if (!cmd58(ocr))
        return false;

    if (SD_HIGH_CAPACITY(ocr))
        _hc = true;
    else
        _hc = false;

    return true;
}

template < pin_t CS, template < pin_t, pin_t, pin_t > class SPI, pin_t MOSI, pin_t MISO, pin_t SCK >
bool DevSD < CS, SPI, MOSI, MISO, SCK >::getCSD(void)
{
    uint8_t resp = sendCmd(REQ_CMD9_HEAD, REQ_CMD9_ARG, REQ_CMD9_TAIL);

    if (resp & RESP_R1_ERROR)
    {
        endCmd();
        return false;
    }

    // In bytes, i.e number of 8-bit transfers
    static constexpr uint8_t const resp_tries = 8;

    // Wait for response
    for (uint8_t i = 0; i < resp_tries; i++)
    {
        if ((resp = this->_spi.txrx8(0xFF)) != SD_FLOATING_BUS)
            break;
    }

    if (resp != RESP_START_BLOCK_TOKEN)
    {
        endCmd();
        return false;
    }

    // 16 bytes + CRC16
    this->_spi.trans(nullptr, 0, _csd._buffer, sizeof(_csd._buffer));
    this->_spi.tx16(0xFFFF); // Ignore CRC16

    endCmd();

    return true;
}

template < pin_t CS, template < pin_t, pin_t, pin_t > class SPI, pin_t MOSI, pin_t MISO, pin_t SCK >
bool DevSD < CS, SPI, MOSI, MISO, SCK >::getCID(void)
{
    uint8_t resp = sendCmd(REQ_CMD10_HEAD, REQ_CMD10_ARG, REQ_CMD10_TAIL);

    if (resp & RESP_R1_ERROR)
    {
        endCmd();
        return false;
    }

    // In bytes, i.e number of 8-bit transfers
    static constexpr uint8_t const resp_tries = 8;

    // Wait for response
    for (uint8_t i = 0; i < resp_tries; i++)
    {
        if ((resp = this->_spi.txrx8(0xFF)) != SD_FLOATING_BUS)
            break;
    }

    if (resp != RESP_START_BLOCK_TOKEN)
    {
        endCmd();
        return false;
    }

    // 16 bytes + CRC16
    this->_spi.trans(nullptr, 0, _cid._buffer, sizeof(_cid._buffer));
    this->_spi.tx16(0xFFFF); // Ignore CRC16

    endCmd();

    return true;
}

// uint32_t addr - a sector on the disk
template < pin_t CS, template < pin_t, pin_t, pin_t > class SPI, pin_t MOSI, pin_t MISO, pin_t SCK >
bool DevSD < CS, SPI, MOSI, MISO, SCK >::read(uint32_t addr, uint8_t (&buf)[SD_READ_BLK_LEN])
{
    static uint32_t const read_timeout = 100;
    uint8_t resp = sendCmd(REQ_CMD17_HEAD, REQ_CMD17_ARG(addr, _hc), REQ_CMD17_TAIL);

    if (resp & RESP_R1_ERROR)
    {
        endCmd();
        return false;
    }

    uint32_t ts = msecs();
    while (true)
    {
        resp = this->_spi.txrx8(0xFF);
        if ((resp != SD_FLOATING_BUS) || ((msecs() - ts) > read_timeout))
            break;
    }

    if (resp != RESP_START_BLOCK_TOKEN)
    {
        endCmd();
        return false;
    }

    // Total of 514 bytes, 512 bytes data + CRC16
    this->_spi.trans(nullptr, 0, buf, SD_READ_BLK_LEN);
    this->_spi.tx16(0xFFFF); // Ignore CRC16

    endCmd();

    return true;
}

// uint32_t addr - a sector on the disk
template < pin_t CS, template < pin_t, pin_t, pin_t > class SPI, pin_t MOSI, pin_t MISO, pin_t SCK >
bool DevSD < CS, SPI, MOSI, MISO, SCK >::write(uint32_t addr, uint8_t (&buf)[SD_READ_BLK_LEN])
{
    static uint32_t const write_timeout = 250;
    uint8_t resp = sendCmd(REQ_CMD24_HEAD, REQ_CMD24_ARG(addr, _hc), REQ_CMD24_TAIL);

    if (resp & RESP_R1_ERROR)
    {
        endCmd();
        return false;
    }

    // Total of 515 bytes, Start Block Token + 512 bytes data + CRC16
    this->_spi.tx8(RESP_START_BLOCK_TOKEN);
    this->_spi.trans(buf, SD_READ_BLK_LEN, nullptr, 0);
    this->_spi.tx16(0xFFFF); // CRC16 Don't care
    this->_spi.flush();  // Chuck data shifted in

    // Data Response Token
    resp = this->_spi.txrx8(0xFF);
    if (!RESP_DATA_RESPONSE_TOKEN_ACCEPTED(resp))
    {
        endCmd();

        resp = sendCmd(REQ_CMD13_HEAD, REQ_CMD13_ARG, REQ_CMD13_TAIL);
        (void)this->_spi.txrx8(0xFF);  // R2 response

        // XXX Check status

        endCmd();
        return false;
    }

    uint32_t ts = msecs();
    while (true)
    {
        resp = this->_spi.txrx8(0xFF);
        if ((resp != SD_BUSY) || ((msecs() - ts) > write_timeout))
            break;
    }

    // Still busy after 250 ms - assume card is not going to respond
    if (resp == SD_BUSY)
    {
        endCmd();
        return false;
    }

    endCmd();

    return true;
}

////////////////////////////////////////////////////////////////////////////////
// Templates ///////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
using TDisk = DevSD < PIN_SD_CS, SPI0, PIN_MOSI, PIN_MISO, PIN_SCK >;

#endif
