#ifndef _DISK_H_
#define _DISK_H_

#include "dev.h"
#include "spi.h"
#include "spi_cta.h"
#include "types.h"
#include "dma.h"
//#include <string.h>   // For manufacturer string

#define SD_BLOCK_LEN  512

template < pin_t CS, template < pin_t, pin_t, pin_t > class SPI, pin_t MOSI, pin_t MISO, pin_t SCK >
class DevSD : public DevDisk < SD_BLOCK_LEN, CS, SPI, MOSI, MISO, SCK >
{
    using Tdisk = DevDisk < SD_BLOCK_LEN, CS, SPI, MOSI, MISO, SCK >;

    public:
        static DevSD & acquire(void) { static DevSD sd; return sd; }
        virtual bool valid(void) { return Tdisk::valid() && _valid; }
        virtual bool busy(void) { return _busy; }

        virtual int read(uint32_t addr, uint8_t (&buf)[SD_BLOCK_LEN]);
        virtual int write(uint32_t addr, uint8_t (&buf)[SD_BLOCK_LEN]);

        virtual dd_desc_t open(uint32_t addr, uint16_t num_blocks, dd_dir_e dir);
        virtual int read(dd_desc_t dd, uint8_t * buf, uint16_t blen);
        virtual int write(dd_desc_t dd, uint8_t * data, uint16_t dlen);
        virtual int close(dd_desc_t dd);

        virtual uint32_t reserve(uint32_t bytes);

        virtual uint32_t capacity(void);  // In kilobytes
        virtual uint32_t blocks(void);

        //virtual dd_err_e errno(void);

        DevSD(DevSD const &) = delete;
        DevSD & operator=(DevSD const &) = delete;

    private:
        enum cmd_e : uint8_t
        {
            // GO_IDLE_STATE
            // Resets SD Memory Card.  Used in this context to put the card into SPI mode.
            // CRC only necessary for CMD0 since when sending this the card is
            // in SD as opposed to SPI mode which requires a checksum.  After
            // this command is sent, the card is in SPI mode which does not require
            // a valid checksum unless explicitly set via CMD59
            // R1 response
            GO_IDLE_STATE = 0,

            // SEND_IF_COND
            // Sends SD Memory Card interface condition that includes host supply voltage
            // information and asks the accessed card whether it can operate in the
            // supplied voltage range.
            // This command was introduced in the SD Group's Physical Layer Specification Version 2.00.
            // If the illegal command bit is set in the R1 response, then the card is a Version 1.X
            // SD Memory Card and therefore a Standard Capacity SD Memory Card - SDSC
            // A valid CRC7 is always required for this command regardless of the CMD59 setting.
            // R7 response
            SEND_IF_COND = 8,

            // SEND_CSD
            // Asks card to send its card-specific data (CSD)
            SEND_CSD = 9,

            // SEND_CID
            // Asks card to send its card identification (CID)
            SEND_CID = 10,

            // STOP_TRANSMISSION
            STOP_TRANSMISSION = 12,

            // SEND_STATUS
            // Asks the card to send its status register.  Will get an R2 response.
            SEND_STATUS = 13,

            // READ_SINGLE_BLOCK
            // For SDSC, reads a block of the size selected by the SET_BLOCKLEN command
            // (CMD16) which if not explicitly set, supposedly defaults to 512 bytes.
            // For SDHC and SDXC, reads a block of size 512 bytes regardless of SET_BLOCKLEN
            // command.  Argument for SDSC is a byte offset and for SDHC and SDXC, a block offset.
            // R1 response followed by a start block token then block size bytes of data and
            // suffixed with a 16-bit CRC generated by the standard CCITT
            // polynomial x^16 + x^12 + x^5 + 1.
            // If card cannot provide required data, a data error token will be sent
            // instead of a start block token.
            READ_SINGLE_BLOCK = 17,

            // READ_MULTIPLE_BLOCK
            READ_MULTIPLE_BLOCK = 18,

            // WRITE_BLOCK
            // For SDSC, write a block of the size selected by the SET_BLOCKLEN command
            // (CMD16) which if not explicitly set, supposedly defaults to 512 bytes.
            // For SDHC and SDXC, write a block of size 512 bytes regardless of SET_BLOCKLEN
            // command.  Argument for SDSC is a byte offset and for SDHC and SDXC, a block offset.
            // R1 response followed by writing a start block token then block size bytes of data
            // and suffixed with a 16-bit CRC generated by the standard CCITT
            // polynomial x^16 + x^12 + x^5 + 1.  Will get a data response token followed by
            // some length of time where the line is held low or busy.  If the data response
            // token indicates an error, use CMD13 (SEND_STATUS) to get specific error.
            WRITE_BLOCK = 24,

            // WRITE_MULTIPLE_BLOCK
            WRITE_MULTIPLE_BLOCK = 25,

            // APP_CMD
            // Must be sent before application specific commands, i.e. ACMDs.  Really used
            // in this context before sending an ACMD41 which is one of many that are already
            // "reserved for the SD Memory Card proprietary applications and shall not be used
            // by any SD Memory Card manufacturer".
            // R1 response
            APP_CMD = 55,

            // READ_OCR
            // Reads the OCR register of the card.  If the CCS (Card Capacity Status) bit
            // is set in the response, then this is a high capacity card - SDHC or SDXC -
            // otherwise it is standard capacity - SDSC.  The difference matters in block
            // reads, writes and locks.  SDSC argument is a byte offset and SDHC and
            // SDXC argument is a 512 byte block offset.
            // R3 response
            READ_OCR = 58,
        };

        enum acmd_e : uint8_t
        {
            // SD_SEND_OP_COND
            // Sends host capacity support information and activates the card's
            // initialization process.  Set HCS bit to say we support high
            // capacity cards if CMD8 was recognized.  This command must be repeatedly
            // sent until the idle state bit is cleared in the response.
            // R1 response
            SD_SEND_OP_COND = 41,
        };

        // Format R1 response
        enum r1_e : uint8_t
        {
            R1_READY            = 0,
            R1_IDLE_STATE       = (1 << 0),
            R1_ERASE_RESET      = (1 << 1),
            R1_ERR_ILLEGAL_CMD  = (1 << 2),
            R1_ERR_CMD_CRC      = (1 << 3),
            R1_ERR_ERASE_SEQ    = (1 << 4),
            R1_ERR_ADDRESS      = (1 << 5),
            R1_ERR_PARAMETER    = (1 << 6),
            R1_TRANSMIT         = (1 << 7),  // Should NEVER be set
        };

        static uint8_t r1Error(uint8_t r1)
        {
            return r1 & (
                R1_ERR_ILLEGAL_CMD |
                R1_ERR_CMD_CRC     |
                R1_ERR_ERASE_SEQ   |
                R1_ERR_ADDRESS     |
                R1_ERR_PARAMETER   |
                0);
        }

        // Format R2 response
        enum r2_e : uint8_t
        {
            R2_ERR_CARD_LOCKED                    = (1 << 0),
            R2_ERR_WP_ERASE_OR_LOCK_UNLOCK_FAILED = (1 << 1),
            R2_ERR_GENERAL_OR_UNKNOWN             = (1 << 2),
            R2_ERR_CARD_CONTROLLER                = (1 << 3),
            R2_ERR_CARD_ECC_FAILED                = (1 << 4),
            R2_ERR_WRITE_PROTECT_VIOLATION        = (1 << 5),
            R2_ERR_INVALID_ERASE_PARAM            = (1 << 6),
            R2_ERR_OUT_OF_RANGE_OR_CSD            = (1 << 7),
        };

        // OCR register in R3 response
        enum ocr_e
        {
            OCR_LOW_VOLTAGE_RANGE    = (1 << 7),
            OCR_VDD_2_7_to_2_8       = (1 << 15),
            OCR_VDD_2_8_to_2_9       = (1 << 16),
            OCR_VDD_2_9_to_3_0       = (1 << 17),
            OCR_VDD_3_0_to_3_1       = (1 << 18),
            OCR_VDD_3_1_to_3_2       = (1 << 19),
            OCR_VDD_3_2_to_3_3       = (1 << 20),
            OCR_VDD_3_3_to_3_4       = (1 << 21),
            OCR_VDD_3_4_to_3_5       = (1 << 22),
            OCR_VDD_3_5_to_3_6       = (1 << 23),
            OCR_SWITCH_1_8_ACCEPTED  = (1 << 24),
            OCR_UHS_II_CARD_STATUS   = (1 << 29),
            OCR_CARD_CAPACITY_STATUS = (1 << 30),
            OCR_CARD_POWER_UP_STATUS = (1 << 31),
        };

        static bool highCapacity(uint32_t ocr) { return ocr & OCR_CARD_CAPACITY_STATUS; }

        // Data Response Token
        //
        //   7   6   5   4   3   2   1   0
        // ---------------------------------
        // | x | x | x | 0 |  Status   | 1 |
        // ---------------------------------
        //
        // Status bits
        // ----------------------------------------
        // 010 - Data accepted
        // 101 - Data rejected due to a CRC error
        // 110 - Data rejected due to a Write error
        enum drt_e : uint8_t
        {
            DRT_ACCEPTED    = 2,
            DRT_CRC_ERROR   = 5,
            DRT_WRITE_ERROR = 6,
        };

        static bool drtValid(uint8_t drt) { return (drt & 0x11) == 0x01; }
        static uint8_t drtStatus(uint8_t drt) { return (drt >> 1) & 0x07; }
        static bool drtAccepted(uint8_t drt) { return drtValid(drt) && (drtStatus(drt) == DRT_ACCEPTED); }
        static bool drtCrcError(uint8_t drt) { return drtValid(drt) && (drtStatus(drt) == DRT_CRC_ERROR); }
        static bool drtWriteError(uint8_t drt) { return drtValid(drt) && (drtStatus(drt) == DRT_WRITE_ERROR); }

        // Data Error Token
        enum det_e : uint8_t
        {
            DET_GENERAL_OR_UNKNOWN   = (1 << 0),
            DET_CARD_CONTROLLER      = (1 << 1),
            DET_CARD_ECC_FAILED      = (1 << 2),
            DET_OUT_OF_RANGE_OR_CSD  = (1 << 3),
        };

        enum token_e : uint8_t
        {
            TOKEN_BUSY = 0x00,
            TOKEN_START_BLOCK_WMB = 0xFC, // For WRITE_MULTIPLE_BLOCK
            TOKEN_STOP_TRAN = 0xFD,       // For WRITE_MULTIPLE_BLOCK
            TOKEN_START_BLOCK = 0xFE,     // For READ_SINGLE_BLOCK, READ_MULTIPLE_BLOCK and WRITE_BLOCK
            TOKEN_HIGH = 0xFF,
        };

        static constexpr uint16_t const _s_bsize = 1024;

        class DiskDesc : public DMA::Isr, public ProducerConsumer < _s_bsize >
        {
            public:
                enum chunk_e : uint16_t
                {
                    C1 = 1, C2 = 2, C4 = 4, C8 = 8, C16 = 16, C32 = 32,
                    C64 = 64, C128 = 128, C256 = 256, C512 = 512
                };

                DiskDesc(void) = default;

                //virtual uint16_t produceLen(uint16_t len = BSIZE) const final;
                //virtual uint16_t consumeLen(uint16_t len = BSIZE) const final;

                //virtual bool canProduce(uint16_t len) const final;
                //virtual bool canConsume(uint16_t len) const final;

                //virtual uint16_t produce(uint8_t * data, uint16_t dlen, bool allow_trunc = false) final;
                //virtual uint16_t consume(uint8_t * buf, uint16_t blen, bool allow_trunc = false) final;

                //virtual uint32_t consumed(void) const final;
                //virtual uint32_t produced(void) const final;

                //virtual bool consumeDone(void) const final;
                //virtual bool produceDone(void) const final;

                bool stalled(void) const { return _stalled; }
                bool error(void) const { return _error; }

                bool start(uint32_t total, dd_dir_e dir);
                void resume(void);
                void stop(void);

                bool done(void) const;
                bool dir(void) const { return _dir; }

            private:
                virtual void isr(DMA::Channel & ch) { (_dir == DD_READ) ? read() : write(); }

                void init(void);
                void read(void);
                void write(void);
                void abort(void);
                void _resume(void);

                enum dds_e : uint8_t
                {
                    WAIT_READY,
                    START_BLOCK,
                    DATA,
                    CHKSUM,
                    DATA_RESPONSE,
                    WAIT_BUSY
                };

                dds_e volatile _state;

                chunk_e const _chunk = C64;
                dd_dir_e volatile _dir = DD_READ;

                uint8_t volatile _pushr;
                uint8_t volatile _popr;

                bool volatile _stalled = false;
                bool volatile _error = false;

                TCD _tcd_tx;
                TCD _tcd_rx;

                DMA::Channel * _ch_rx = nullptr;
                DMA::Channel * _ch_tx = nullptr;

                SPI < MOSI, MISO, SCK > & _spi = SPI < MOSI, MISO, SCK >::acquire();
        };

        DevSD(void);

        uint8_t sendCommand(uint8_t cmd_num, uint32_t arg = 0);
        uint8_t sendCmd(cmd_e cmd, uint32_t arg = 0) { return sendCommand(cmd, arg); }
        uint8_t sendAcmd(acmd_e acmd, uint32_t arg = 0);
        uint16_t sendStatus(void);
        void endCmd(void);

        void clock74(void);
        bool spiMode(void);
        bool checkVersion(void);
        bool readOCR(uint32_t & ocr);
        bool checkVoltage(void);
        bool ready(void);
        bool checkCapacity(void);
        bool readCSD(void);
        bool readCID(void);

        uint32_t address(uint32_t addr) { return _hc ? addr : (addr << 9); }
        int error(dd_err_e errno, bool abort = false)
        {
            this->_errno = errno;
            if (abort) endCmd();
            return -1;
        }

        static constexpr uint8_t const _s_start_bit = 0x00;
        static constexpr uint8_t const _s_trans_bit = 0x40;
        static constexpr uint8_t const _s_end_bit = 0x01;

        bool _hcs = false;
        bool _hc = false;

        bool _busy = false;
        bool _valid = true;

        uint32_t _blocks = 0;
        uint32_t _reserved = 0;

        bool _crc = true;
        uint8_t _crc7_table[256];
        void crc7Init(void);
        uint8_t crc7(uint8_t cmd_num, uint32_t arg);

        DiskDesc _disk_desc;

        ////////////////////////////////////////////////////////////////////////////////////////////////////
        //
        // CSD Version 1.0
        //
        // Name                              Field              Width          Value   Cell Type   CSD-slice
        // -------------------------------------------------------------------------------------------------
        // CSD Structure                     CSD_STRUCTURE          2            00b       R       [127:126]
        // reserved                          -                      6       00 0000b       R       [125:120]
        // data read access-time-1           TAAC                   8            xxh       R       [119:112]
        // data read access-time-2           NSAC                   8            xxh       R       [111:104]
        // max. data transfer rate           TRAN_SPEED             8     32h or 5Ah       R       [103:96]
        // card command classes              CCC                   12  01x110110101b       R       [95:84]
        // max. read data block length       READ_BL_LEN            4             xh       R       [83:80]
        // partial blocks for read allowed   READ_BL_PARTIAL        1             1b       R       [79:79]
        // write block misalignment          WRITE_BLK_MISALIGN     1             xb       R       [78:78]
        // read block misalignment           READ_BLK_MISALIGN      1             xb       R       [77:77]
        // DSR implemented                   DSR_IMP                1             xb       R       [76:76]
        // reserved                          -                      2            00b       R       [74:75]
        // device size                       C_SIZE                12           xxxh       R       [73:62]
        // max. read current @ VDD min       VDD_R_CURR_MIN         3           xxxb       R       [61:59]
        // max. read current @ VDD max       VDD_R_CURR_MAX         3           xxxb       R       [58:56]
        // max. write current @ VDD min      VDD_W_CURR_MIN         3           xxxb       R       [55:53]
        // max. write current @ VDD max      VDD_W_CURR_MAX         3           xxxb       R       [52:50]
        // device size multiplier            C_SIZE_MULT            3           xxxb       R       [49:47]
        // erase single block enable         ERASE_BLK_EN           1             xb       R       [46:46]
        // erase sector size                 SECTOR_SIZE            7       xxxxxxxb       R       [45:39]
        // write protect group size          WP_GRP_SIZE            7       xxxxxxxb       R       [38:32]
        // write protect group enable        WP_GRP_ENABLE          1             xb       R       [31:31]
        // reserved                          -                      2            00b       R       [30:29]
        // write speed factor                R2W_FACTOR             3           xxxb       R       [28:26]
        // max. write data block length      WRITE_BL_LEN           4          xxxxb       R       [25:22]
        // partial blocks for write allowed  WRITE_BL_PARTIAL       1             xb       R       [21:21]
        // reserved                          -                      5         00000b       R       [20:16]
        // File format group                 FILE_FORMAT_GRP        1             xb      R/W(1)   [15:15]
        // copy flag                         COPY                   1             xb      R/W(1)   [14:14]
        // permanent write protection        PERM_WRITE_PROTECT     1             xb      R/W(1)   [13:13]
        // temporary write protection        TMP_WRITE_PROTECT      1             xb      R/W      [12:12]
        // File format                       FILE_FORMAT            2            xxb      R/W(1)   [11:10]
        // reserved                          -                      2            00b      R/W      [9:8]
        // CRC                               CRC                    7       xxxxxxxb      R/W      [7:1]
        // not used, always '1'              -                      1             1b       -       [0:0]
        //
        // R = readable, W(1) = writable once, W = multiple writable
        //
        ////////////////////////////////////////////////////////////////////////////////////////////////////
        //
        // CSD Version 2.0
        //
        // Name                              Field              Width          Value   Cell Type   CSD-slice
        // -------------------------------------------------------------------------------------------------
        // CSD Structure                     CSD_STRUCTURE          2            01b       R       [127:126]
        // reserved                          -                      6       00 0000b       R       [125:120]
        // data read access-time-1           TAAC                   8            0Eh       R       [119:112]
        // data read access-time-2           NSAC                   8            00h       R       [111:104]
        // max. data transfer rate           TRAN_SPEED             8  32h,5Ah,0Bh,2Bh     R       [103:96]
        // card command classes              CCC                   12  x1x110110101b       R       [95:84]
        // max. read data block length       READ_BL_LEN            4             9h       R       [83:80]
        // partial blocks for read allowed   READ_BL_PARTIAL        1             0b       R       [79:79]
        // write block misalignment          WRITE_BLK_MISALIGN     1             0b       R       [78:78]
        // read block misalignment           READ_BLK_MISALIGN      1             0b       R       [77:77]
        // DSR implemented                   DSR_IMP                1             xb       R       [76:76]
        // reserved                          -                      6       00 0000b       R       [75:70]
        // device size                       C_SIZE                22        xxxxxxh       R       [69:48]
        // reserved                          -                      1             0b       R       [47:47]
        // erase single block enable         ERASE_BLK_EN           1             1b       R       [46:46]
        // erase sector size                 SECTOR_SIZE            7            7Fh       R       [45:39]
        // write protect group size          WP_GRP_SIZE            7       0000000b       R       [38:32]
        // write protect group enable        WP_GRP_ENABLE          1             0b       R       [31:31]
        // reserved                          -                      2            00b       R       [30:29]
        // write speed factor                R2W_FACTOR             3           010b       R       [28:26]
        // max. write data block length      WRITE_BL_LEN           4             9h       R       [25:22]
        // partial blocks for write allowed  WRITE_BL_PARTIAL       1             0b       R       [21:21]
        // reserved                          -                      5         00000b       R       [20:16]
        // File format group                 FILE_FORMAT_GRP        1             0b       R       [15:15]
        // copy flag                         COPY                   1             xb      R/W(1)   [14:14]
        // permanent write protection        PERM_WRITE_PROTECT     1             xb      R/W(1)   [13:13]
        // temporary write protection        TMP_WRITE_PROTECT      1             xb      R/W      [12:12]
        // File format                       FILE_FORMAT            2            00b       R       [11:10]
        // reserved                          -                      2            00b       R       [9:8]
        // CRC                               CRC                    7       xxxxxxxb      R/W      [7:1]
        // not used, always '1'              -                      1             1b       -       [0:0]
        //
        // R = readable, W(1) = writable once, W = multiple writable
        //
        ////////////////////////////////////////////////////////////////////////////////////////////////////
        struct CSD
        {
            // XXX Should never get a Version 1.0 CSD since high/extended capacity is a requirement
            enum version_e : uint8_t
            {
                VERSION_1_0,  // Standard Capacity Card
                VERSION_2_0,  // High and Extended Capacity Cards
                RESERVED_2,
                RESERVED_3,
            };

            // In Kilobytes
            uint32_t cardCapacity(void) const
            {
                uint32_t capacity = 0;

                if (csd_structure() == VERSION_1_0)
                {
                    uint32_t block_len = 1 << read_bl_len();   // READ_BL_LEN < 12 ???
                    uint32_t mult = 1 << (c_size_mult() + 2);  // C_SIZE_MULT <  8 ???
                    uint32_t blocknr = (c_size() + 1) * mult;
                    capacity = (blocknr * block_len) / 1024;
                }
                else if (csd_structure() == VERSION_2_0)
                {
                    capacity = (c_size() + 1) * SD_BLOCK_LEN;
                }

                return capacity;
            }

            uint32_t numBlocks(void) const
            {
                uint32_t num_blocks = 0;

                if (csd_structure() == VERSION_1_0)
                {
                    uint32_t mult = 1 << (c_size_mult() + 2);
                    num_blocks = (c_size() + 1) * mult;
                }
                else if (csd_structure() == VERSION_2_0)
                {
                    // Will wrap to 0 if card is max capacity of 2 TB
                    // If card capacity is not zero then a return value of zero
                    // indicates 2^32, otherwise 0.
                    num_blocks = (c_size() + 1) * 1024;
                }

                return num_blocks;
            }

            uint32_t readBlockLen(void) const { return 1 << read_bl_len(); }
            uint32_t writeBlockLen(void) const { return 1 << write_bl_len(); }

            // Data is transmitted MSb first so byte ordering will be the reverse of the above
            // but bit ordering in byte will be the same.

            version_e csd_structure(void) const { return (version_e)((_buffer[0] & 0xC0) >> 6); }
            uint8_t taac(void) const { return _buffer[1]; }
            uint8_t nsac(void) const { return _buffer[2]; }
            uint8_t trans_speed(void) const { return _buffer[3]; }
            uint16_t ccc(void) const { return ((uint16_t)_buffer[4] << 4) | (_buffer[5] >> 4); }
            uint8_t read_bl_len(void) const { return _buffer[5] & 0x0F; }
            bool read_bl_partial(void) const { return _buffer[6] & 0x80; }
            bool write_blk_misalign(void) const { return _buffer[6] & 0x40; }
            bool read_blk_misalign(void) const { return _buffer[6] & 0x20; }
            bool dsr_imp(void) const { return _buffer[6] & 0x10; }

            uint32_t c_size(void) const
            {
                uint32_t csize = 0;

                if (csd_structure() == VERSION_1_0)
                    csize = ((uint32_t)(_buffer[6] & 0x03) << 10)
                        | ((uint32_t)_buffer[7] << 2) | ((_buffer[8] & 0xC0) >> 6);
                else if (csd_structure() == VERSION_2_0)
                    csize = ((uint32_t)(_buffer[7] & 0x3F) << 16) | ((uint32_t)_buffer[8] << 8) | _buffer[9];

                return csize;
            }

            // Only for v1
            uint8_t vdd_r_curr_min(void) const { return (_buffer[8] & 0x38) >> 3; }
            uint8_t vdd_r_curr_max(void) const { return _buffer[8] & 0x07; }
            uint8_t vdd_w_curr_min(void) const { return (_buffer[9] & 0xE0) >> 5; }
            uint8_t vdd_w_curr_max(void) const { return (_buffer[9] & 0x1C) >> 2; }
            uint8_t c_size_mult(void) const { return ((_buffer[9] & 0x03) << 1) | ((_buffer[10] & 0x80) >> 7); }

            bool erase_blk_en(void) const { return _buffer[10] & 0x40; }
            uint8_t sector_size(void) const { return ((_buffer[10] & 0x3F) << 1) | ((_buffer[11] & 0x80) >> 7); }
            uint8_t wp_grp_size(void) const { return _buffer[11] & 0x7F; }
            bool wp_grp_enable(void) const { return _buffer[12] & 0x80; }
            uint8_t r2w_factor(void) const { return (_buffer[12] & 0x1C) >> 2; }
            uint8_t write_bl_len(void) const { return ((_buffer[12] & 0x03) << 2) | ((_buffer[13] & 0xC0) >> 6); }
            bool write_bl_partial(void) const { return _buffer[13] & 0x20; }
            bool file_format_grp(void) const { return _buffer[14] & 0x80; }
            bool copy(void) const { return _buffer[14] & 0x40; }
            bool perm_write_protect(void) const { return _buffer[14] & 0x20; }
            bool tmp_write_protect(void) const { return _buffer[14] & 0x10; }
            uint8_t file_format(void) const { return (_buffer[14] & 0x0C) >> 2; }
            uint8_t crc(void) const { return (_buffer[15] & 0xFE) >> 1; }
            bool always_one(void) const { return _buffer[15] & 0x01; }

            uint8_t _buffer[16];
        };

        CSD _csd;

        ////////////////////////////////////////////////////////////////////////
        //
        // CID Register
        //
        // Name                      Field    Width     CID-slice
        // ------------------------------------------------------
        // Manufacturer ID           MID          8     [127:120]
        // OEM/Application ID        OID         16     [119:104]
        // Product Name              PNM         40     [103:64]
        // Product Revision          PRV          8     [63:56]
        // Product Serial Number     PSN         32     [55:24]
        // reserved                  ---          4     [23:20]
        // Manufacturing Date        MDT         12     [19:8]
        // CRC7 checksum             CRC          7     [7:1]
        // not used, always 1        ---          1     [0:0]
        //
        ////////////////////////////////////////////////////////////////////////
        struct CID
        {
            // Taken from linux kernel drivers/mmc/core/card.h, tesing and
            // online sources.  Commented entries are from linux kernel code.
            enum manufacturer_id_e : uint8_t
            {
                PANASONIC  = 0x01,
                TOSHIBA    = 0x02,
                //SANDISK    = 0x02,
                SANDISK    = 0x03,
                ATP        = 0x09,
                //TOSHIBA    = 0x11,
                MICRON     = 0x13,
                //SAMSUNG    = 0x15,
                SAMSUNG    = 0x1B,  // Obtained from testing
                ADATA      = 0x1D,
                PATRIOT    = 0x27,
                //APACER     = 0x27,
                APACER     = 0x28,
                //KINGSTON   = 0x70,  // Most Kingston seem to be Toshiba
                HYNIX      = 0x90,
            };

            enum oem_id_e : uint16_t
            {
                OEM_PANASONIC  = 0x5041,  // "PA"
                OEM_TOSHIBA    = 0x544D,  // "TM"
                OEM_SANDISK    = 0x5344,  // "SD"
                OEM_ATP        = 0x4150,  // "AP"
                OEM_SAMSUNG    = 0x534D,  // "SM"
                OEM_ADATA      = 0x4144,  // "AD"
                OEM_PATRIOT    = 0x5048,  // "PH"
                OEM_APACER     = 0x4245,  // "BE"
            };

            // Data is transmitted MSb first so byte ordering will be the reverse of the above
            // but bit ordering in byte will be the same.

            uint8_t mid(void) const { return _buffer[0]; }
            uint16_t oid(void) const { return ((uint16_t)_buffer[1] << 8) | (uint16_t)_buffer[2]; }
            uint8_t const * pnm(void) const { return &_buffer[3]; }
            uint8_t prv(void) const { return _buffer[8]; }
            uint32_t psn(void) const
            {
                return ((uint32_t)_buffer[9] << 24) | ((uint32_t)_buffer[10] << 16)
                    | ((uint32_t)_buffer[11] <<  8) | ((uint32_t)_buffer[12] <<  0);
            }

            uint16_t mdt(void) const { return (((uint16_t)_buffer[13] & 0x0F) << 8) | (uint16_t)_buffer[14]; }
            uint8_t crc(void) const { return (_buffer[15] & 0xFE) >> 1; }
            bool always_one(void) const { return _buffer[15] & 0x01; }

            uint8_t _buffer[16];
        };

        CID _cid;

#if 0
        uint8_t _manufacturer[16];
        uint8_t _product_name[6];

        void setManufacturer(void)
        {
            switch (_cid.mid())
            {
                case CID::PANASONIC:
                    strcpy(_manufacturer, "PANASONIC");
                    break;
                case CID::TOSHIBA:
                    strcpy(_manufacturer, "TOSHIBA");
                    break;
                case CID::SANDISK:
                    strcpy(_manufacturer, "SANDISK");
                    break;
                case CID::ATP:
                    strcpy(_manufacturer, "ATP");
                    break;
                case CID::MICRON:
                    strcpy(_manufacturer, "MICRON");
                    break;
                case CID::SAMSUNG:
                    strcpy(_manufacturer, "SAMSUNG");
                    break;
                case CID::ADATA:
                    strcpy(_manufacturer, "ADATA");
                    break;
                case CID::PATRIOT:
                    strcpy(_manufacturer, "PATRIOT");
                    break;
                case CID::APACER:
                    strcpy(_manufacturer, "APACER");
                    break;
                case CID::HYNIX:
                    strcpy(_manufacturer, "HYNIX");
                    break;
                default:
                    strcpy(_manufacturer, "UNKNOWN");
                    break;
            }
        }

        void setProductName(void) { memcpy(_product_name, _cid.pnm(), 5); _product_name[5] = 0; }
#endif
};

template < pin_t CS, template < pin_t, pin_t, pin_t > class SPI, pin_t MOSI, pin_t MISO, pin_t SCK >
DevSD < CS, SPI, MOSI, MISO, SCK >::DevSD(void)
{
    crc7Init();

    if (!valid())
        return;

    // Start with a 375kHz clock - largest clock less than 400kHz
    // Not really clear from spec what other values should be
    this->_cta = spi_cta(400000, 0, 0, 0);

    clock74();

    _crc = true;

    if (!spiMode() || !checkVersion())
    {
        _valid = false;
        return;
    }

    _crc = false;

    if (!checkVoltage() || !ready() || !checkCapacity())
    {
        _valid = false;
        return;
    }

    // Can set clock higher now.  May actually be able to do after ready.
    this->_cta = spi_cta(25000000, 0, 0, 0);

    (void)readCSD();
    if ((_csd.readBlockLen() != _csd.writeBlockLen())
            || (_csd.readBlockLen() != SD_BLOCK_LEN))
    {
        _valid = false;
        return;
    }

    (void)readCID();

    _blocks = _csd.numBlocks();
}

template < pin_t CS, template < pin_t, pin_t, pin_t > class SPI, pin_t MOSI, pin_t MISO, pin_t SCK >
uint32_t DevSD < CS, SPI, MOSI, MISO, SCK >::reserve(uint32_t bytes)
{
    _reserved += ceiling(bytes, SD_BLOCK_LEN);
    return _blocks - _reserved;
}

template < pin_t CS, template < pin_t, pin_t, pin_t > class SPI, pin_t MOSI, pin_t MISO, pin_t SCK >
uint32_t DevSD < CS, SPI, MOSI, MISO, SCK >::capacity(void)
{
    return (_blocks - _reserved) / 2;
}

template < pin_t CS, template < pin_t, pin_t, pin_t > class SPI, pin_t MOSI, pin_t MISO, pin_t SCK >
uint32_t DevSD < CS, SPI, MOSI, MISO, SCK >::blocks(void)
{
    return _blocks - _reserved;
}

template < pin_t CS, template < pin_t, pin_t, pin_t > class SPI, pin_t MOSI, pin_t MISO, pin_t SCK >
void DevSD < CS, SPI, MOSI, MISO, SCK >::crc7Init(void)
{
    auto divide = [](uint8_t input) -> uint8_t
    {
        // Generator polynomial: G(x) = x^7 + x^3 + 1 -> 10001001b
        static uint8_t const polynomial = 0x89;

        return (input & 0x80) ? input ^ polynomial : input;
    };

    _crc7_table[0] = 0;

    for (uint16_t i = 1; i < 256; i++)
    {
        uint8_t shift = clz8(i);
        uint8_t result = i << shift;

        while (7 > shift++)
            result = divide(result) << 1;

        _crc7_table[i] = divide(result);
    }
}

template < pin_t CS, template < pin_t, pin_t, pin_t > class SPI, pin_t MOSI, pin_t MISO, pin_t SCK >
uint8_t DevSD < CS, SPI, MOSI, MISO, SCK >::crc7(uint8_t cmd_num, uint32_t arg)
{
    uint8_t result = 0;

    result = _crc7_table[(result << 1) ^ (_s_start_bit | _s_trans_bit | cmd_num)];
    result = _crc7_table[(result << 1) ^ ((uint8_t)(arg >> 24))];
    result = _crc7_table[(result << 1) ^ ((uint8_t)(arg >> 16))];
    result = _crc7_table[(result << 1) ^ ((uint8_t)(arg >>  8))];
    result = _crc7_table[(result << 1) ^ ((uint8_t)(arg >>  0))];

    return result;
}

template < pin_t CS, template < pin_t, pin_t, pin_t > class SPI, pin_t MOSI, pin_t MISO, pin_t SCK >
uint8_t DevSD < CS, SPI, MOSI, MISO, SCK >::sendCommand(uint8_t cmd_num, uint32_t arg)
{
    _busy = true;

    // All commands will get an R1 response and according to the
    // specification it can take up to NCR (command response timeout)
    // times to get one.  A SanDisk spec sheet indicates this can be
    // a maximum of 8 units, each unit being 8 clock cycles, so
    // try 8 times to get a response.  It seems that the line
    // will be held high or floating until a valid repsonse is seen.
    // Also, a response never has the first bit set so that may be a
    // valid check as well.

    uint8_t start = _s_start_bit | _s_trans_bit | cmd_num;
    uint8_t end = _crc ? ((crc7(cmd_num, arg) << 1) | _s_end_bit) : (0xFE | _s_end_bit);

    this->_spi.begin(this->_pin, this->_cta);

    // Send command
    this->_spi.tx8(start);
    this->_spi.tx32(arg);
    this->_spi.tx8(end);
    this->_spi.flush();

    // In bytes, i.e number of 8-bit transfers
    static uint8_t const r1_resp_tries = 8;

    // Wait for response
    uint8_t r1;
    for (uint8_t i = 0; i < r1_resp_tries; i++)
    {
        if ((r1 = this->_spi.txrx8()) != TOKEN_HIGH)
            break;
    }

    return r1;
}

template < pin_t CS, template < pin_t, pin_t, pin_t > class SPI, pin_t MOSI, pin_t MISO, pin_t SCK >
uint8_t DevSD < CS, SPI, MOSI, MISO, SCK >::sendAcmd(acmd_e acmd, uint32_t arg)
{
    uint8_t r1 = sendCmd(APP_CMD);
    if (r1Error(r1))
        return r1;

    endCmd();

    return sendCommand(acmd, arg);
}

template < pin_t CS, template < pin_t, pin_t, pin_t > class SPI, pin_t MOSI, pin_t MISO, pin_t SCK >
uint16_t DevSD < CS, SPI, MOSI, MISO, SCK >::sendStatus(void)
{
    uint8_t r1 = sendCmd(SEND_STATUS);

    if (r1 == TOKEN_HIGH)
        return r1;

    uint16_t r2 = ((uint16_t)r1 << 8) | this->_spi.txrx8();

    endCmd();

    return r2;
}

template < pin_t CS, template < pin_t, pin_t, pin_t > class SPI, pin_t MOSI, pin_t MISO, pin_t SCK >
void DevSD < CS, SPI, MOSI, MISO, SCK >::endCmd(void)
{
    this->_spi.end(this->_pin);
    (void)this->_spi.txrx8();  // I think spec says to do this or at least wait 8 clocks.
    _busy = false;
}

template < pin_t CS, template < pin_t, pin_t, pin_t > class SPI, pin_t MOSI, pin_t MISO, pin_t SCK >
void DevSD < CS, SPI, MOSI, MISO, SCK >::clock74(void)
{
    // Number of clocks to send *without* chip select asserted before sending
    // first command.  Specification says a minimum of 74 clocks.  Send 80.
    // 6.4.1.1 Power Up Time of Card (third bullet)
    // * ... In case of SPI mode, CS shall be held to high during 74 clock cycles.
    static uint8_t const sd_init_clocks = 80;

    _busy = true;

    this->_spi.begin(this->_cta);

    for (uint8_t i = 0; i < (sd_init_clocks >> 4); i++)
        this->_spi.tx16();

    this->_spi.end();

    _busy = false;
}

template < pin_t CS, template < pin_t, pin_t, pin_t > class SPI, pin_t MOSI, pin_t MISO, pin_t SCK >
bool DevSD < CS, SPI, MOSI, MISO, SCK >::spiMode(void)
{
    static uint32_t const cmd0_timeout = 250;
    uint8_t r1;
    uint32_t ts = msecs();

    while (((r1 = sendCmd(GO_IDLE_STATE)) != R1_IDLE_STATE) && ((msecs() - ts) < cmd0_timeout))
        endCmd();

    endCmd();

    return (r1 == R1_IDLE_STATE);
}

template < pin_t CS, template < pin_t, pin_t, pin_t > class SPI, pin_t MOSI, pin_t MISO, pin_t SCK >
bool DevSD < CS, SPI, MOSI, MISO, SCK >::checkVersion(void)
{
    enum vhs_e : uint32_t { VHS_2_7_TO_3_6 = 1, VHS_LOW_VOLTAGE };
    static uint32_t const check_pattern = 0xAA;
    static uint32_t const argument = (VHS_2_7_TO_3_6 << 8) | check_pattern;

    uint8_t r1 = sendCmd(SEND_IF_COND, argument);

    if (r1Error(r1) == R1_ERR_ILLEGAL_CMD)
    {
        _hc = _hcs = false;
    }
    else if (r1Error(r1))
    {
        endCmd();
        return false;
    }
    else
    {
        uint32_t r7 = this->_spi.txrx32();
        if ((r7 & 0x00000FFF) != argument)
        {
            endCmd();
            return false;
        }

        _hcs = true;
    }

    endCmd();

    return true;
}

template < pin_t CS, template < pin_t, pin_t, pin_t > class SPI, pin_t MOSI, pin_t MISO, pin_t SCK >
bool DevSD < CS, SPI, MOSI, MISO, SCK >::readOCR(uint32_t & ocr)
{
    uint8_t r1 = sendCmd(READ_OCR);

    if (r1Error(r1))
    {
        endCmd();
        return false;
    }

    ocr = this->_spi.txrx32();

    endCmd();

    return true;
}

template < pin_t CS, template < pin_t, pin_t, pin_t > class SPI, pin_t MOSI, pin_t MISO, pin_t SCK >
bool DevSD < CS, SPI, MOSI, MISO, SCK >::checkVoltage(void)
{
    static uint32_t const ocr_vdd =
        OCR_VDD_2_7_to_2_8  |
        OCR_VDD_2_8_to_2_9  |
        OCR_VDD_2_9_to_3_0  |
        OCR_VDD_3_0_to_3_1  |
        OCR_VDD_3_1_to_3_2  |
        OCR_VDD_3_2_to_3_3  |
        OCR_VDD_3_3_to_3_4  |
        OCR_VDD_3_4_to_3_5  |
        OCR_VDD_3_5_to_3_6  |
        0;

    uint32_t ocr;

    if (!readOCR(ocr))
        return false;

    // XXX Should probably zero in on a value or smaller set of values
    if (!(ocr & ocr_vdd))
        return false;

    return true;
}

template < pin_t CS, template < pin_t, pin_t, pin_t > class SPI, pin_t MOSI, pin_t MISO, pin_t SCK >
bool DevSD < CS, SPI, MOSI, MISO, SCK >::ready(void)
{
    static uint32_t const acmd41_timeout = 1500;
    uint8_t r1;
    uint32_t arg = _hcs ? (1 << 30) : 0;
    uint32_t ts = msecs();

    while (((r1 = sendAcmd(SD_SEND_OP_COND, arg)) == R1_IDLE_STATE) && ((msecs() - ts) < acmd41_timeout))
        endCmd();

    endCmd();

    return (r1 == R1_READY);
}

template < pin_t CS, template < pin_t, pin_t, pin_t > class SPI, pin_t MOSI, pin_t MISO, pin_t SCK >
bool DevSD < CS, SPI, MOSI, MISO, SCK >::checkCapacity(void)
{
    uint32_t ocr;

    if (!_hcs)
        return true;

    if (!readOCR(ocr))
        return false;

    if (highCapacity(ocr))
        _hc = true;
    else
        _hc = false;

    return true;
}

template < pin_t CS, template < pin_t, pin_t, pin_t > class SPI, pin_t MOSI, pin_t MISO, pin_t SCK >
bool DevSD < CS, SPI, MOSI, MISO, SCK >::readCSD(void)
{
    uint8_t resp = sendCmd(SEND_CSD);

    if (r1Error(resp))
    {
        endCmd();
        return false;
    }

    // In bytes, i.e number of 8-bit transfers
    static uint8_t const resp_tries = 8;

    // Wait for response
    for (uint8_t i = 0; i < resp_tries; i++)
    {
        if ((resp = this->_spi.txrx8()) != TOKEN_HIGH)
            break;
    }

    if (resp != TOKEN_START_BLOCK)
    {
        endCmd();
        return false;
    }

    // 16 bytes + CRC16
    this->_spi.trans(nullptr, 0, _csd._buffer, sizeof(_csd._buffer));
    this->_spi.tx16(); // Ignore CRC16

    endCmd();

    return true;
}

template < pin_t CS, template < pin_t, pin_t, pin_t > class SPI, pin_t MOSI, pin_t MISO, pin_t SCK >
bool DevSD < CS, SPI, MOSI, MISO, SCK >::readCID(void)
{
    uint8_t resp = sendCmd(SEND_CID);

    if (r1Error(resp))
    {
        endCmd();
        return false;
    }

    // In bytes, i.e number of 8-bit transfers
    static uint8_t const resp_tries = 8;

    // Wait for response
    for (uint8_t i = 0; i < resp_tries; i++)
    {
        if ((resp = this->_spi.txrx8()) != TOKEN_HIGH)
            break;
    }

    if (resp != TOKEN_START_BLOCK)
    {
        endCmd();
        return false;
    }

    // 16 bytes + CRC16
    this->_spi.trans(nullptr, 0, _cid._buffer, sizeof(_cid._buffer));
    this->_spi.tx16(); // Ignore CRC16

    endCmd();

    return true;
}

// uint32_t addr - a sector on the disk
template < pin_t CS, template < pin_t, pin_t, pin_t > class SPI, pin_t MOSI, pin_t MISO, pin_t SCK >
int DevSD < CS, SPI, MOSI, MISO, SCK >::read(uint32_t addr, uint8_t (&buf)[SD_BLOCK_LEN])
{
    static uint32_t const read_timeout = 100;

    addr = address(addr);

    if (addr >= _blocks)
        return error(DD_ERR_INVAL);
    else if (busy())
        return error(DD_ERR_BUSY);

    uint8_t resp = sendCmd(READ_SINGLE_BLOCK, addr);

    if (r1Error(resp))
        return error(DD_ERR_IO, true);

    uint32_t ts = msecs();
    while (((resp = this->_spi.txrx8()) == TOKEN_HIGH) && ((msecs() - ts) < read_timeout));

    if (resp != TOKEN_START_BLOCK)
        return error(DD_ERR_TIMED_OUT, true);

    // Total of 514 bytes, 512 bytes data + CRC16
    this->_spi.trans(nullptr, 0, buf, SD_BLOCK_LEN);
    this->_spi.tx16(); // Ignore CRC16

    endCmd();

    return SD_BLOCK_LEN;
}

// uint32_t addr - a sector on the disk
template < pin_t CS, template < pin_t, pin_t, pin_t > class SPI, pin_t MOSI, pin_t MISO, pin_t SCK >
int DevSD < CS, SPI, MOSI, MISO, SCK >::write(uint32_t addr, uint8_t (&buf)[SD_BLOCK_LEN])
{
    static uint32_t const write_timeout = 250;

    addr = address(addr);

    if (addr >= _blocks)
        return error(DD_ERR_INVAL);
    else if (busy())
        return error(DD_ERR_BUSY);

    uint8_t resp = sendCmd(WRITE_BLOCK, addr);
    if (r1Error(resp))
        return error(DD_ERR_IO, true);

    // Total of 515 bytes, Start Block Token + 512 bytes data + CRC16
    this->_spi.tx8(TOKEN_START_BLOCK);
    this->_spi.trans(buf, SD_BLOCK_LEN, nullptr, 0);
    this->_spi.tx16(); // CRC16 Don't care
    this->_spi.flush();  // Chuck data shifted in

    // Data Response Token
    resp = this->_spi.txrx8();
    if (!drtAccepted(resp))
    {
        (void)error(DD_ERR_IO, true);

        // XXX Check status
        //uint16_t status = sendStatus();

        return -1;
    }

    uint32_t ts = msecs();
    while (((resp = this->_spi.txrx8()) == TOKEN_BUSY) && ((msecs() - ts) < write_timeout));

    if (resp == TOKEN_BUSY)
        return error(DD_ERR_TIMED_OUT, true);

    endCmd();

    return SD_BLOCK_LEN;
}

template < pin_t CS, template < pin_t, pin_t, pin_t > class SPI, pin_t MOSI, pin_t MISO, pin_t SCK >
dd_desc_t DevSD < CS, SPI, MOSI, MISO, SCK >::open(uint32_t addr, uint16_t num_blocks, dd_dir_e dir)
{
    auto open_error = [&](dd_err_e errno, bool abort = false) -> dd_desc_t
    {
        (void)error(errno, abort);
        return nullptr;
    };

    addr = address(addr);

    if (busy())
        return open_error(DD_ERR_BUSY);

    if ((num_blocks == 0) || ((addr + num_blocks) > _blocks) || ((addr + num_blocks) < addr))
        return open_error(DD_ERR_INVAL);

    uint8_t r1;

    if (dir == DD_READ)
        r1 = sendCmd(READ_MULTIPLE_BLOCK, addr);
    else
        r1 = sendCmd(WRITE_MULTIPLE_BLOCK, addr);

    if (r1Error(r1))
        return open_error(DD_ERR_IO, true);

    if (!_disk_desc.start((uint32_t)num_blocks * SD_BLOCK_LEN, dir))
    {
        close(&_disk_desc);
        return open_error(DD_ERR_BUSY, true);
    }

    return &_disk_desc;
}

template < pin_t CS, template < pin_t, pin_t, pin_t > class SPI, pin_t MOSI, pin_t MISO, pin_t SCK >
int DevSD < CS, SPI, MOSI, MISO, SCK >::read(dd_desc_t dd, uint8_t * buf, uint16_t blen)
{
    if (!busy() || (dd != &_disk_desc) || (_disk_desc.dir() != DD_READ))
        return error(DD_ERR_BADF);

    if (_disk_desc.error())
        return error(DD_ERR_BADFD);

    uint16_t n;
    if (_disk_desc.consumeDone() || ((n = _disk_desc.consume(buf, blen)) == 0))
        return 0;

    if (_disk_desc.stalled())
        _disk_desc.resume();

    return n;
}

template < pin_t CS, template < pin_t, pin_t, pin_t > class SPI, pin_t MOSI, pin_t MISO, pin_t SCK >
int DevSD < CS, SPI, MOSI, MISO, SCK >::write(dd_desc_t dd, uint8_t * data, uint16_t dlen)
{
    if (!busy() || (dd != &_disk_desc) || (_disk_desc.dir() != DD_WRITE))
        return error(DD_ERR_BADF);

    if (_disk_desc.error())
        return error(DD_ERR_BADFD);

    uint16_t n;
    if (_disk_desc.produceDone() || ((n = _disk_desc.produce(data, dlen)) == 0))
        return 0;

    if (_disk_desc.stalled())
        _disk_desc.resume();

    return n;
}

template < pin_t CS, template < pin_t, pin_t, pin_t > class SPI, pin_t MOSI, pin_t MISO, pin_t SCK >
int DevSD < CS, SPI, MOSI, MISO, SCK >::close(dd_desc_t dd)
{
    if (!busy() || (dd != &_disk_desc))
        return error(DD_ERR_BADF);

    _disk_desc.stop();

    if (_disk_desc.dir() == DD_READ)
    {
        static constexpr uint32_t const read_timeout = 100;

        // Response is type R1b so a busy signal may follow.
        // Physical Layer Simplified Specification 4.10 - 4.3.3 Data Read, * Block Read
        //  The stop command has an execution delay due to the serial command transmission.
        //  The data transfer stops after the end bit of the stop command.
        // Response always seems to be 0x7F - tested SanDisk and Samsung

        uint8_t r1b = sendCmd(STOP_TRANSMISSION);
        if (r1b == TOKEN_HIGH) // Timeout
            return error(DD_ERR_TIMED_OUT, true);

        uint32_t ts = msecs();
        while (((r1b = this->_spi.txrx8()) == TOKEN_BUSY) && ((msecs() - ts) < read_timeout));

        if (r1b == TOKEN_BUSY)
            return error(DD_ERR_TIMED_OUT, true);

        endCmd();
    }
    else
    {
        static constexpr uint32_t const write_timeout = 250;

        (void)this->_spi.txrx8(TOKEN_STOP_TRAN);

        // Some extra clocks are sometimes necessary before the busy signal test.
        for (uint8_t i = 0; i < 8; i++)
            (void)this->_spi.txrx8();

        uint16_t status;
        uint32_t ts = msecs();

        while (((status = this->_spi.txrx8()) != TOKEN_HIGH) && ((msecs() - ts) < write_timeout));

        if (status != TOKEN_HIGH)
            return error(DD_ERR_TIMED_OUT, true);

        endCmd();

        // XXX Actually check status
        status = sendStatus();
    }

    return 0;
}

template < pin_t CS, template < pin_t, pin_t, pin_t > class SPI, pin_t MOSI, pin_t MISO, pin_t SCK >
bool DevSD < CS, SPI, MOSI, MISO, SCK >::DiskDesc::start(uint32_t total, dd_dir_e dir)
{
    _ch_tx = DMA::acquire();
    _ch_rx = DMA::acquire();

    if ((_ch_rx == nullptr) || (_ch_tx == nullptr))
    {
        DMA::release(_ch_rx);
        DMA::release(_ch_tx);
        _ch_rx = _ch_tx = nullptr;

        return false;
    }

    _dir = dir;
    _total = total;
    _produced = _consumed = 0;
    _stalled = _error = false;

    init();

    // Must enable SPI DMA signals before starting channels
    _spi.dmaEnable();

    // Must start RX first or risk missing a signal if TX finishes before RX start
    _ch_rx->start(_tcd_rx, DMA::Channel::SPI0_RX, this);
    _ch_tx->start(_tcd_tx, DMA::Channel::SPI0_TX);

    return true;
}

template < pin_t CS, template < pin_t, pin_t, pin_t > class SPI, pin_t MOSI, pin_t MISO, pin_t SCK >
void DevSD < CS, SPI, MOSI, MISO, SCK >::DiskDesc::resume(void)
{
    if ((_ch_tx == nullptr) || (_ch_rx == nullptr)
            || ((_dir == DD_READ) && !canProduce(_chunk))
            || ((_dir == DD_WRITE) && !canConsume(_chunk)))
    {
        return;
    }

    _stalled = false;

    _resume();
}

template < pin_t CS, template < pin_t, pin_t, pin_t > class SPI, pin_t MOSI, pin_t MISO, pin_t SCK >
void DevSD < CS, SPI, MOSI, MISO, SCK >::DiskDesc::_resume(void)
{
    // Must resume RX first or risk missing a signal if TX finishes before RX start
    _ch_rx->resume();
    _ch_tx->resume();
}

template < pin_t CS, template < pin_t, pin_t, pin_t > class SPI, pin_t MOSI, pin_t MISO, pin_t SCK >
void DevSD < CS, SPI, MOSI, MISO, SCK >::DiskDesc::stop(void)
{
    while (!done());
    abort();
}

template < pin_t CS, template < pin_t, pin_t, pin_t > class SPI, pin_t MOSI, pin_t MISO, pin_t SCK >
void DevSD < CS, SPI, MOSI, MISO, SCK >::DiskDesc::abort(void)
{
    _spi.dmaDisable();
    DMA::release(_ch_tx);
    DMA::release(_ch_rx);
    _ch_rx = _ch_tx = nullptr;
}

template < pin_t CS, template < pin_t, pin_t, pin_t > class SPI, pin_t MOSI, pin_t MISO, pin_t SCK >
bool DevSD < CS, SPI, MOSI, MISO, SCK >::DiskDesc::done(void) const
{
    if (_dir == DD_READ)
        return (_state == WAIT_READY) && produceDone();
    else
        return (_state == START_BLOCK) && consumeDone();
}

template < pin_t CS, template < pin_t, pin_t, pin_t > class SPI, pin_t MOSI, pin_t MISO, pin_t SCK >
void DevSD < CS, SPI, MOSI, MISO, SCK >::DiskDesc::init(void)
{
    memset(&_tcd_tx, 0, sizeof(TCD));
    memset(&_tcd_rx, 0, sizeof(TCD));

    if (_dir == DD_READ)
    {
        _state = WAIT_READY;
        _pushr = TOKEN_HIGH;
    }
    else
    {
        _state = START_BLOCK;
        _pushr = TOKEN_START_BLOCK_WMB;
    }

    _tcd_tx.saddr = (void volatile *)&_pushr;
    _tcd_tx.daddr = (void volatile *)_spi.writeReg();
    _tcd_tx.nbytes = 1;
    _tcd_tx.biter = 1;
    _tcd_tx.citer = 1;
    _tcd_tx.dreq = 1;

    _tcd_rx.saddr = (void volatile *)_spi.readReg();
    _tcd_rx.daddr = (void volatile *)&_popr;
    _tcd_rx.nbytes = 1;
    _tcd_rx.biter = 1;
    _tcd_rx.citer = 1;
    _tcd_rx.intmajor = 1;
    _tcd_rx.dreq = 1;
}

template < pin_t CS, template < pin_t, pin_t, pin_t > class SPI, pin_t MOSI, pin_t MISO, pin_t SCK >
void DevSD < CS, SPI, MOSI, MISO, SCK >::DiskDesc::read(void)
{
    auto wait_ready = [&](void) -> void
    {
        if (_popr != TOKEN_START_BLOCK)
            return;

        _state = DATA;

        _tcd_tx.biter = _chunk;
        _tcd_tx.citer = _chunk;

        _tcd_rx.daddr = (void volatile *)(_buffer + (_produced % _s_bsize));
        _tcd_rx.doff = 1;
        _tcd_rx.biter = _chunk;
        _tcd_rx.citer = _chunk;

        _ch_tx->update(_tcd_tx);
        _ch_rx->update(_tcd_rx);

        if (!canProduce(_chunk))
            _stalled = true;
    };

    auto data = [&](void) -> void
    {
        _produced += _chunk;

        if ((_produced % SD_BLOCK_LEN) == 0)
            _state = CHKSUM;
        else if (!canProduce(_chunk))
            _stalled = true;

        if (_state == DATA)
            return;

        _tcd_tx.biter = 2;
        _tcd_tx.citer = 2;

        _tcd_rx.daddr = (void volatile *)&_popr;
        _tcd_rx.doff = 0;
        _tcd_rx.biter = 2;
        _tcd_rx.citer = 2;

        _ch_tx->update(_tcd_tx);
        _ch_rx->update(_tcd_rx);
    };

    auto chksum = [&](void) -> void
    {
        _state = WAIT_READY;

        _tcd_tx.biter = 1;
        _tcd_tx.citer = 1;

        _tcd_rx.biter = 1;
        _tcd_rx.citer = 1;

        _ch_tx->update(_tcd_tx);
        _ch_rx->update(_tcd_rx);
    };

    switch (_state)
    {
        case WAIT_READY: wait_ready(); break;
        case DATA: data(); break;
        case CHKSUM: chksum(); break;
        default: _error = true; break;
    }

    if (error())
        abort();

    if (!error() && !done() && !stalled())
        _resume();
}

template < pin_t CS, template < pin_t, pin_t, pin_t > class SPI, pin_t MOSI, pin_t MISO, pin_t SCK >
void DevSD < CS, SPI, MOSI, MISO, SCK >::DiskDesc::write(void)
{
    auto start_block = [&](void) -> void
    {
        _state = DATA;

        _tcd_tx.saddr = (void volatile *)(_buffer + (_consumed % _s_bsize));
        _tcd_tx.soff = 1;
        _tcd_tx.biter = _chunk;
        _tcd_tx.citer = _chunk;

        _tcd_rx.biter = _chunk;
        _tcd_rx.citer = _chunk;

        _ch_tx->update(_tcd_tx);
        _ch_rx->update(_tcd_rx);

        if (!canConsume(_chunk))
            _stalled = true;
    };

    auto data = [&](void) -> void
    {
        _consumed += _chunk;

        if ((_consumed % SD_BLOCK_LEN) == 0)
            _state = CHKSUM;
        else if (!canConsume(_chunk))
            _stalled = true;

        if (_state == DATA)
            return;

        _pushr = TOKEN_HIGH;
        _tcd_tx.saddr = (void volatile *)&_pushr;
        _tcd_tx.soff = 0;
        _tcd_tx.biter = 2;
        _tcd_tx.citer = 2;

        _tcd_rx.biter = 2;
        _tcd_rx.citer = 2;

        _ch_tx->update(_tcd_tx);
        _ch_rx->update(_tcd_rx);
    };

    auto chksum = [&](void) -> void
    {
        _state = DATA_RESPONSE;

        _tcd_tx.biter = 1;
        _tcd_tx.citer = 1;

        _tcd_rx.biter = 1;
        _tcd_rx.citer = 1;

        _ch_tx->update(_tcd_tx);
        _ch_rx->update(_tcd_rx);
    };

    auto data_response = [&](void) -> void
    {
        if (drtAccepted(_popr))
            _state = WAIT_BUSY;
        else
            _error = true;
    };

    auto wait_busy = [&](void) -> void
    {
        if (_popr == TOKEN_BUSY)
            return;

        _state = START_BLOCK;
        _pushr = TOKEN_START_BLOCK_WMB;
    };

    switch (_state)
    {
        case START_BLOCK: start_block(); break;
        case DATA: data(); break;
        case CHKSUM: chksum(); break;
        case DATA_RESPONSE: data_response(); break;
        case WAIT_BUSY: wait_busy(); break;
        default: _error = true; break;
    }

    if (error())
        abort();

    if (!error() && !done() && !stalled())
        _resume();
}

////////////////////////////////////////////////////////////////////////////////
// Templates ///////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
using TDisk = DevSD < PIN_SD_CS, SPI0, PIN_MOSI, PIN_MISO, PIN_SCK >;

#endif
